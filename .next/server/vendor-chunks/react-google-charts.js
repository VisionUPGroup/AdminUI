"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-google-charts";
exports.ids = ["vendor-chunks/react-google-charts"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-google-charts/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-google-charts/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chart: () => (/* binding */ Chart$1),\n/* harmony export */   GoogleDataTableColumnRoleType: () => (/* binding */ GoogleDataTableColumnRoleType),\n/* harmony export */   \"default\": () => (/* binding */ Chart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/**\n * Hook to load external script.\n * @param src - Source url to load.\n * @param onLoad - Success callback.\n * @param onError - Error callback.\n */ function useLoadScript(src, onLoad, onError) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!document) {\n            return;\n        }\n        // Find script tag with same src in DOM.\n        const foundScript = document.querySelector('script[src=\"'.concat(src, '\"]'));\n        // Call onLoad if script marked as loaded.\n        if (foundScript === null || foundScript === void 0 ? void 0 : foundScript.dataset.loaded) {\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad();\n            return;\n        }\n        // Create or get existed tag.\n        const script = foundScript || document.createElement(\"script\");\n        // Set src if no script was found.\n        if (!foundScript) {\n            script.src = src;\n        }\n        // Mark script as loaded on load event.\n        const onLoadWithMarker = ()=>{\n            script.dataset.loaded = \"1\";\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad();\n        };\n        script.addEventListener(\"load\", onLoadWithMarker);\n        if (onError) {\n            script.addEventListener(\"error\", onError);\n        }\n        // Add to DOM if not yet added.\n        if (!foundScript) {\n            document.head.append(script);\n        }\n    }, []);\n}\n\n/**\n * Hook to load Google Charts JS API.\n * @param params - Load parameters.\n * @param [params.chartVersion] - Chart version to load.\n * @param [params.chartPackages] - Packages to load.\n * @param [params.chartLanguage] - Languages to load.\n * @param [params.mapsApiKey] - Google Maps api key.\n * @returns\n */ function useLoadGoogleCharts(param) {\n    let { chartVersion =\"current\" , chartPackages =[\n        \"corechart\",\n        \"controls\"\n    ] , chartLanguage =\"en\" , mapsApiKey  } = param;\n    const [googleCharts, setGoogleCharts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [failed, setFailed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    useLoadScript(\"https://www.gstatic.com/charts/loader.js\", ()=>{\n        // @ts-expect-error Getting object from global namespace.\n        const google = window === null || window === void 0 ? void 0 : window.google;\n        if (!google) {\n            return;\n        }\n        google.charts.load(chartVersion, {\n            packages: chartPackages,\n            language: chartLanguage,\n            mapsApiKey\n        });\n        google.charts.setOnLoadCallback(()=>{\n            setGoogleCharts(google);\n        });\n    }, ()=>{\n        setFailed(true);\n    });\n    return [\n        googleCharts,\n        failed\n    ];\n}\n/**\n * Wrapper around useLoadGoogleCharts to use in legacy components.\n */ function LoadGoogleCharts(param) {\n    let { onLoad , onError , ...params } = param;\n    const [googleCharts, failed] = useLoadGoogleCharts(params);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (googleCharts && onLoad) {\n            onLoad(googleCharts);\n        }\n    }, [\n        googleCharts\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (failed && onError) {\n            onError();\n        }\n    }, [\n        failed\n    ]);\n    return null;\n}\n\nconst chartDefaultProps = {\n    // <DEPRECATED_PROPS>\n    legend_toggle: false,\n    // </DEPRECATED_PROPS>\n    options: {},\n    legendToggle: false,\n    getChartWrapper: ()=>{},\n    spreadSheetQueryParameters: {\n        headers: 1,\n        gid: 1\n    },\n    rootProps: {},\n    chartWrapperParams: {}\n};\n\nlet uniqueID = 0;\nconst generateUniqueID = ()=>{\n    uniqueID += 1;\n    return \"reactgooglegraph-\".concat(uniqueID);\n};\n\nconst DEFAULT_CHART_COLORS = [\n    \"#3366CC\",\n    \"#DC3912\",\n    \"#FF9900\",\n    \"#109618\",\n    \"#990099\",\n    \"#3B3EAC\",\n    \"#0099C6\",\n    \"#DD4477\",\n    \"#66AA00\",\n    \"#B82E2E\",\n    \"#316395\",\n    \"#994499\",\n    \"#22AA99\",\n    \"#AAAA11\",\n    \"#6633CC\",\n    \"#E67300\",\n    \"#8B0707\",\n    \"#329262\",\n    \"#5574A6\",\n    \"#3B3EAC\"\n];\n\nconst loadDataTableFromSpreadSheet = async function(googleViz, spreadSheetUrl) {\n    let urlParams = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return new Promise((resolve, reject)=>{\n        const headers = \"\".concat(urlParams.headers ? \"headers=\".concat(urlParams.headers) : \"headers=0\");\n        const queryString = \"\".concat(urlParams.query ? \"&tq=\".concat(encodeURIComponent(urlParams.query)) : \"\");\n        const gid = \"\".concat(urlParams.gid ? \"&gid=\".concat(urlParams.gid) : \"\");\n        const sheet = \"\".concat(urlParams.sheet ? \"&sheet=\".concat(urlParams.sheet) : \"\");\n        const access_token = \"\".concat(urlParams.access_token ? \"&access_token=\".concat(urlParams.access_token) : \"\");\n        const urlQueryString = \"\".concat(headers).concat(gid).concat(sheet).concat(queryString).concat(access_token);\n        const urlToSpreadSheet = \"\".concat(spreadSheetUrl, \"/gviz/tq?\").concat(urlQueryString); //&tq=${queryString}`;\n        const query = new googleViz.visualization.Query(urlToSpreadSheet);\n        query.send((response)=>{\n            if (response.isError()) {\n                reject(\"Error in query:  \".concat(response.getMessage(), \" \").concat(response.getDetailedMessage()));\n            } else {\n                resolve(response.getDataTable());\n            }\n        });\n    });\n};\n\nconst { Provider , Consumer  } = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(chartDefaultProps);\nconst ContextProvider = (param)=>{\n    let { children , value  } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n        value: value\n    }, children);\n};\nconst ContextConsumer = (param)=>{\n    let { render  } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Consumer, null, (context)=>{\n        return render(context);\n    });\n};\n\nconst GRAY_COLOR = \"#CCCCCC\";\nclass GoogleChartDataTableInner extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {\n        this.draw(this.props);\n        window.addEventListener(\"resize\", this.onResize);\n        if (this.props.legend_toggle || this.props.legendToggle) {\n            this.listenToLegendToggle();\n        }\n    }\n    componentWillUnmount() {\n        const { google , googleChartWrapper  } = this.props;\n        window.removeEventListener(\"resize\", this.onResize);\n        google.visualization.events.removeAllListeners(googleChartWrapper);\n        if (googleChartWrapper.getChartType() === \"Timeline\") {\n            googleChartWrapper.getChart() && googleChartWrapper.getChart().clearChart();\n        }\n    }\n    componentDidUpdate() {\n        this.draw(this.props);\n    }\n    render() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.state = {\n            hiddenColumns: []\n        };\n        this.listenToLegendToggle = ()=>{\n            const { google , googleChartWrapper  } = this.props;\n            google.visualization.events.addListener(googleChartWrapper, \"select\", ()=>{\n                const chart = googleChartWrapper.getChart();\n                const selection = chart.getSelection();\n                const dataTable = googleChartWrapper.getDataTable();\n                if (selection.length === 0 || // We want to listen to when a whole row is selected. This is the case only when row === null\n                selection[0].row || !dataTable) {\n                    return;\n                }\n                const columnIndex = selection[0].column;\n                const columnID = this.getColumnID(dataTable, columnIndex);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    this.setState((state)=>({\n                            ...state,\n                            hiddenColumns: [\n                                ...state.hiddenColumns.filter((colID)=>colID !== columnID), \n                            ]\n                        }));\n                } else {\n                    this.setState((state)=>({\n                            ...state,\n                            hiddenColumns: [\n                                ...state.hiddenColumns,\n                                columnID\n                            ]\n                        }));\n                }\n            });\n        };\n        this.applyFormatters = (dataTable, formatters)=>{\n            const { google  } = this.props;\n            for (let formatter of formatters){\n                switch(formatter.type){\n                    case \"ArrowFormat\":\n                        {\n                            const vizFormatter = new google.visualization.ArrowFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"BarFormat\":\n                        {\n                            const vizFormatter = new google.visualization.BarFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"ColorFormat\":\n                        {\n                            const vizFormatter = new google.visualization.ColorFormat(formatter.options);\n                            const { ranges  } = formatter;\n                            for (let range of ranges){\n                                vizFormatter.addRange(...range);\n                            }\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"DateFormat\":\n                        {\n                            const vizFormatter = new google.visualization.DateFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"NumberFormat\":\n                        {\n                            const vizFormatter = new google.visualization.NumberFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"PatternFormat\":\n                        {\n                            const vizFormatter = new google.visualization.PatternFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                }\n            }\n        };\n        this.getColumnID = (dataTable, columnIndex)=>{\n            return dataTable.getColumnId(columnIndex) || dataTable.getColumnLabel(columnIndex);\n        };\n        this.draw = async (param)=>{\n            let { data , diffdata , rows , columns , options , legend_toggle , legendToggle , chartType , formatters , spreadSheetUrl , spreadSheetQueryParameters  } = param;\n            const { google , googleChartWrapper  } = this.props;\n            let dataTable;\n            let chartDiff = null;\n            if (diffdata) {\n                const oldData = google.visualization.arrayToDataTable(diffdata.old);\n                const newData = google.visualization.arrayToDataTable(diffdata.new);\n                chartDiff = google.visualization[chartType].prototype.computeDiff(oldData, newData);\n            }\n            if (data) {\n                if (Array.isArray(data)) {\n                    dataTable = google.visualization.arrayToDataTable(data);\n                } else {\n                    dataTable = new google.visualization.DataTable(data);\n                }\n            } else if (rows && columns) {\n                dataTable = google.visualization.arrayToDataTable([\n                    columns,\n                    ...rows\n                ]);\n            } else if (spreadSheetUrl) {\n                dataTable = await loadDataTableFromSpreadSheet(google, spreadSheetUrl, spreadSheetQueryParameters);\n            } else {\n                dataTable = google.visualization.arrayToDataTable([]);\n            }\n            const columnCount = dataTable.getNumberOfColumns();\n            const viewColumns = Array(columnCount).fill(0).map((c, i)=>{\n                const columnID = this.getColumnID(dataTable, i);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    return {\n                        label: dataTable.getColumnLabel(i),\n                        type: dataTable.getColumnType(i),\n                        calc: ()=>null\n                    };\n                } else {\n                    return i;\n                }\n            });\n            const chart = googleChartWrapper.getChart();\n            if (googleChartWrapper.getChartType() === \"Timeline\") {\n                chart && chart.clearChart();\n            }\n            googleChartWrapper.setChartType(chartType);\n            googleChartWrapper.setOptions(options || {});\n            const viewTable = new google.visualization.DataView(dataTable);\n            viewTable.setColumns(viewColumns);\n            googleChartWrapper.setDataTable(viewTable);\n            googleChartWrapper.draw();\n            if (this.props.googleChartDashboard !== null) {\n                this.props.googleChartDashboard.draw(dataTable);\n            }\n            if (chartDiff) {\n                googleChartWrapper.setDataTable(chartDiff);\n                googleChartWrapper.draw();\n            }\n            if (formatters) {\n                this.applyFormatters(dataTable, formatters);\n                googleChartWrapper.setDataTable(dataTable);\n                googleChartWrapper.draw();\n            }\n            if (legendToggle === true || legend_toggle === true) {\n                this.grayOutHiddenColumns({\n                    options\n                });\n            }\n            return;\n        };\n        this.grayOutHiddenColumns = (param)=>{\n            let { options  } = param;\n            const { googleChartWrapper  } = this.props;\n            const dataTable = googleChartWrapper.getDataTable();\n            if (!dataTable) return;\n            const columnCount = dataTable.getNumberOfColumns();\n            const hasAHiddenColumn = this.state.hiddenColumns.length > 0;\n            if (hasAHiddenColumn === false) return;\n            const colors = Array.from({\n                length: columnCount - 1\n            }).map((dontcare, i)=>{\n                const columnID = this.getColumnID(dataTable, i + 1);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    return GRAY_COLOR;\n                } else if (options && options.colors) {\n                    return options.colors[i];\n                } else {\n                    return DEFAULT_CHART_COLORS[i];\n                }\n            });\n            googleChartWrapper.setOptions({\n                ...options,\n                colors\n            });\n            googleChartWrapper.draw();\n        };\n        this.onResize = ()=>{\n            const { googleChartWrapper  } = this.props;\n            googleChartWrapper.draw();\n        };\n    }\n}\nclass GoogleChartDataTable extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {}\n    componentWillUnmount() {}\n    shouldComponentUpdate() {\n        return false;\n    }\n    render() {\n        const { google , googleChartWrapper , googleChartDashboard  } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextConsumer, {\n            render: (props)=>{\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartDataTableInner, Object.assign({}, props, {\n                    google: google,\n                    googleChartWrapper: googleChartWrapper,\n                    googleChartDashboard: googleChartDashboard\n                }));\n            }\n        });\n    }\n}\n\nclass GoogleChartEvents extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate() {\n        return false;\n    }\n    listenToEvents(param) {\n        let { chartEvents , google , googleChartWrapper  } = param;\n        if (!chartEvents) {\n            return;\n        }\n        google.visualization.events.removeAllListeners(googleChartWrapper);\n        for (let event of chartEvents){\n            var _this = this;\n            const { eventName , callback  } = event;\n            google.visualization.events.addListener(googleChartWrapper, eventName, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                callback({\n                    chartWrapper: googleChartWrapper,\n                    props: _this.props,\n                    google: google,\n                    eventArgs: args\n                });\n            });\n        }\n    }\n    componentDidMount() {\n        var ref;\n        const { google , googleChartWrapper  } = this.props;\n        this.listenToEvents({\n            chartEvents: ((ref = this.propsFromContext) === null || ref === void 0 ? void 0 : ref.chartEvents) || null,\n            google,\n            googleChartWrapper\n        });\n    }\n    render() {\n        this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextConsumer, {\n            render: (propsFromContext)=>{\n                this.propsFromContext = propsFromContext;\n                return null;\n            }\n        });\n    }\n    constructor(props){\n        super(props);\n        this.propsFromContext = null;\n    }\n}\n\nlet controlCounter = 0;\nclass GoogleChart extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {\n        const { options , google , chartType , chartWrapperParams , toolbarItems , getChartEditor , getChartWrapper ,  } = this.props;\n        const chartConfig = {\n            chartType,\n            options,\n            containerId: this.getGraphID(),\n            ...chartWrapperParams\n        };\n        const googleChartWrapper = new google.visualization.ChartWrapper(chartConfig);\n        googleChartWrapper.setOptions(options || {});\n        if (getChartWrapper) {\n            getChartWrapper(googleChartWrapper, google);\n        }\n        const googleChartDashboard = new google.visualization.Dashboard(this.dashboard_ref);\n        const googleChartControls = this.addControls(googleChartWrapper, googleChartDashboard);\n        if (toolbarItems) {\n            google.visualization.drawToolbar(this.toolbar_ref.current, toolbarItems);\n        }\n        let googleChartEditor = null;\n        if (getChartEditor) {\n            googleChartEditor = new google.visualization.ChartEditor();\n            getChartEditor({\n                chartEditor: googleChartEditor,\n                chartWrapper: googleChartWrapper,\n                google\n            });\n        }\n        this.setState({\n            googleChartEditor,\n            googleChartControls: googleChartControls,\n            googleChartDashboard: googleChartDashboard,\n            googleChartWrapper,\n            isReady: true\n        });\n    }\n    componentDidUpdate() {\n        if (!this.state.googleChartWrapper) return;\n        if (!this.state.googleChartDashboard) return;\n        if (!this.state.googleChartControls) return;\n        const { controls  } = this.props;\n        if (controls) {\n            for(let i = 0; i < controls.length; i += 1){\n                const { controlType , options , controlWrapperParams  } = controls[i];\n                if (controlWrapperParams && \"state\" in controlWrapperParams) {\n                    this.state.googleChartControls[i].control.setState(controlWrapperParams[\"state\"]);\n                }\n                this.state.googleChartControls[i].control.setOptions(options);\n                this.state.googleChartControls[i].control.setControlType(controlType);\n            }\n        }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        return this.state.isReady !== nextState.isReady || nextProps.controls !== this.props.controls;\n    }\n    render() {\n        const { width , height , options , style  } = this.props;\n        const divStyle = {\n            height: height || options && options.height,\n            width: width || options && options.width,\n            ...style\n        };\n        if (this.props.render) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.dashboard_ref,\n                style: divStyle\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.toolbar_ref,\n                id: \"toolbar\"\n            }), this.props.render({\n                renderChart: this.renderChart,\n                renderControl: this.renderControl,\n                renderToolbar: this.renderToolBar\n            }));\n        } else {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.dashboard_ref,\n                style: divStyle\n            }, this.renderControl((param)=>{\n                let { controlProp  } = param;\n                return controlProp.controlPosition !== \"bottom\";\n            }), this.renderChart(), this.renderControl((param)=>{\n                let { controlProp  } = param;\n                return controlProp.controlPosition === \"bottom\";\n            }), this.renderToolBar());\n        }\n    }\n    constructor(...args1){\n        var _this1;\n        super(...args1), _this1 = this;\n        this.state = {\n            googleChartWrapper: null,\n            googleChartDashboard: null,\n            googleChartControls: null,\n            googleChartEditor: null,\n            isReady: false\n        };\n        this.graphID = null;\n        this.dashboard_ref = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.toolbar_ref = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.getGraphID = ()=>{\n            const { graphID , graph_id  } = this.props;\n            let instanceGraphID;\n            if (!graphID && !graph_id) {\n                if (!this.graphID) {\n                    instanceGraphID = generateUniqueID();\n                } else {\n                    instanceGraphID = this.graphID;\n                }\n            } else if (graphID && !graph_id) {\n                instanceGraphID = graphID;\n            } else if (graph_id && !graphID) {\n                instanceGraphID = graph_id;\n            } else {\n                instanceGraphID = graphID;\n            }\n            this.graphID = instanceGraphID;\n            return this.graphID;\n        };\n        this.getControlID = (id, index)=>{\n            controlCounter += 1;\n            let controlID;\n            if (typeof id === \"undefined\") {\n                controlID = \"googlechart-control-\".concat(index, \"-\").concat(controlCounter);\n            } else {\n                controlID = id;\n            }\n            return controlID;\n        };\n        this.addControls = (googleChartWrapper, googleChartDashboard)=>{\n            const { google , controls  } = this.props;\n            const googleChartControls = !controls ? null : controls.map((control, i)=>{\n                const { controlID: controlIDMaybe , controlType , options: controlOptions , controlWrapperParams ,  } = control;\n                const controlID = this.getControlID(controlIDMaybe, i);\n                return {\n                    controlProp: control,\n                    control: new google.visualization.ControlWrapper({\n                        containerId: controlID,\n                        controlType,\n                        options: controlOptions,\n                        ...controlWrapperParams\n                    })\n                };\n            });\n            if (!googleChartControls) {\n                return null;\n            }\n            googleChartDashboard.bind(googleChartControls.map((param)=>{\n                let { control  } = param;\n                return control;\n            }), googleChartWrapper);\n            for (let chartControl of googleChartControls){\n                const { control , controlProp  } = chartControl;\n                const { controlEvents =[]  } = controlProp;\n                for (let event of controlEvents){\n                    var _this = this;\n                    const { callback , eventName  } = event;\n                    google.visualization.events.removeListener(control, eventName, callback);\n                    google.visualization.events.addListener(control, eventName, function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        callback({\n                            chartWrapper: googleChartWrapper,\n                            controlWrapper: control,\n                            props: _this.props,\n                            google: google,\n                            eventArgs: args\n                        });\n                    });\n                }\n            }\n            return googleChartControls;\n        };\n        this.renderChart = ()=>{\n            const { width , height , options , style , className , rootProps , google  } = this.props;\n            const divStyle = {\n                height: height || options && options.height,\n                width: width || options && options.width,\n                ...style\n            };\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n                id: this.getGraphID(),\n                style: divStyle,\n                className: className\n            }, rootProps), this.state.isReady && this.state.googleChartWrapper !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartDataTable, {\n                googleChartWrapper: this.state.googleChartWrapper,\n                google: google,\n                googleChartDashboard: this.state.googleChartDashboard\n            }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartEvents, {\n                googleChartWrapper: this.state.googleChartWrapper,\n                google: google\n            })) : null);\n        };\n        this.renderControl = function() {\n            let filter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (param)=>{\n                return true;\n            };\n            return _this1.state.isReady && _this1.state.googleChartControls !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, _this1.state.googleChartControls.filter((param)=>{\n                let { controlProp , control  } = param;\n                return filter({\n                    control,\n                    controlProp\n                });\n            }).map((param)=>{\n                let { control , controlProp  } = param;\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                    key: control.getContainerId(),\n                    id: control.getContainerId()\n                });\n            })) : null;\n        };\n        this.renderToolBar = ()=>{\n            if (!this.props.toolbarItems) return null;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.toolbar_ref\n            });\n        };\n    }\n}\n\nclass Chart$1 extends (react__WEBPACK_IMPORTED_MODULE_0__.Component) {\n    render() {\n        const { chartLanguage , chartPackages , chartVersion , mapsApiKey , loader , errorElement ,  } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextProvider, {\n            value: this.props\n        }, this.state.loadingStatus === \"ready\" && this.state.google !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChart, Object.assign({}, this.props, {\n            google: this.state.google\n        })) : this.state.loadingStatus === \"errored\" && errorElement ? errorElement : loader, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LoadGoogleCharts, {\n            chartLanguage: chartLanguage,\n            chartPackages: chartPackages,\n            chartVersion: chartVersion,\n            mapsApiKey: mapsApiKey,\n            onLoad: this.onLoad,\n            onError: this.onError\n        }));\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        this._isMounted = false;\n    }\n    isFullyLoaded(google) {\n        const { controls , toolbarItems , getChartEditor  } = this.props;\n        return google && google.visualization && google.visualization.ChartWrapper && google.visualization.Dashboard && (!controls || google.visualization.ChartWrapper) && (!getChartEditor || google.visualization.ChartEditor) && (!toolbarItems || google.visualization.drawToolbar);\n    }\n    constructor(...args){\n        super(...args);\n        this._isMounted = false;\n        this.state = {\n            loadingStatus: \"loading\",\n            google: null\n        };\n        this.onLoad = (google1)=>{\n            if (this.props.onLoad) {\n                this.props.onLoad(google1);\n            }\n            if (this.isFullyLoaded(google1)) {\n                this.onSuccess(google1);\n            } else {\n                // IE11: window.google is not fully set, we have to wait\n                const id = setInterval(()=>{\n                    const google = window.google;\n                    if (this._isMounted) {\n                        if (google && this.isFullyLoaded(google)) {\n                            clearInterval(id);\n                            this.onSuccess(google);\n                        }\n                    } else {\n                        clearInterval(id);\n                    }\n                }, 1000);\n            }\n        };\n        this.onSuccess = (google)=>{\n            this.setState({\n                loadingStatus: \"ready\",\n                google\n            });\n        };\n        this.onError = ()=>{\n            this.setState({\n                loadingStatus: \"errored\"\n            });\n        };\n    }\n}\nChart$1.defaultProps = chartDefaultProps;\n\nvar GoogleDataTableColumnRoleType;\n(function(GoogleDataTableColumnRoleType) {\n    GoogleDataTableColumnRoleType[\"annotation\"] = \"annotation\";\n    GoogleDataTableColumnRoleType[\"annotationText\"] = \"annotationText\";\n    GoogleDataTableColumnRoleType[\"certainty\"] = \"certainty\";\n    GoogleDataTableColumnRoleType[\"emphasis\"] = \"emphasis\";\n    GoogleDataTableColumnRoleType[\"interval\"] = \"interval\";\n    GoogleDataTableColumnRoleType[\"scope\"] = \"scope\";\n    GoogleDataTableColumnRoleType[\"style\"] = \"style\";\n    GoogleDataTableColumnRoleType[\"tooltip\"] = \"tooltip\";\n    GoogleDataTableColumnRoleType[\"domain\"] = \"domain\";\n})(GoogleDataTableColumnRoleType || (GoogleDataTableColumnRoleType = {}));\n\nvar Chart = Chart$1;\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ29vZ2xlLWNoYXJ0cy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDYTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDLCtDQUFRO0FBQ3BELGdDQUFnQywrQ0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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bXVsdGlrYXJ0LW5leHQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ29vZ2xlLWNoYXJ0cy9kaXN0L2luZGV4LmpzP2JlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBIb29rIHRvIGxvYWQgZXh0ZXJuYWwgc2NyaXB0LlxuICogQHBhcmFtIHNyYyAtIFNvdXJjZSB1cmwgdG8gbG9hZC5cbiAqIEBwYXJhbSBvbkxvYWQgLSBTdWNjZXNzIGNhbGxiYWNrLlxuICogQHBhcmFtIG9uRXJyb3IgLSBFcnJvciBjYWxsYmFjay5cbiAqLyBmdW5jdGlvbiB1c2VMb2FkU2NyaXB0KHNyYywgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHNjcmlwdCB0YWcgd2l0aCBzYW1lIHNyYyBpbiBET00uXG4gICAgICAgIGNvbnN0IGZvdW5kU2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYz1cIicuY29uY2F0KHNyYywgJ1wiXScpKTtcbiAgICAgICAgLy8gQ2FsbCBvbkxvYWQgaWYgc2NyaXB0IG1hcmtlZCBhcyBsb2FkZWQuXG4gICAgICAgIGlmIChmb3VuZFNjcmlwdCA9PT0gbnVsbCB8fCBmb3VuZFNjcmlwdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm91bmRTY3JpcHQuZGF0YXNldC5sb2FkZWQpIHtcbiAgICAgICAgICAgIG9uTG9hZCA9PT0gbnVsbCB8fCBvbkxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBvciBnZXQgZXhpc3RlZCB0YWcuXG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IGZvdW5kU2NyaXB0IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgIC8vIFNldCBzcmMgaWYgbm8gc2NyaXB0IHdhcyBmb3VuZC5cbiAgICAgICAgaWYgKCFmb3VuZFNjcmlwdCkge1xuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHNjcmlwdCBhcyBsb2FkZWQgb24gbG9hZCBldmVudC5cbiAgICAgICAgY29uc3Qgb25Mb2FkV2l0aE1hcmtlciA9ICgpPT57XG4gICAgICAgICAgICBzY3JpcHQuZGF0YXNldC5sb2FkZWQgPSBcIjFcIjtcbiAgICAgICAgICAgIG9uTG9hZCA9PT0gbnVsbCB8fCBvbkxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkV2l0aE1hcmtlcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBET00gaWYgbm90IHlldCBhZGRlZC5cbiAgICAgICAgaWYgKCFmb3VuZFNjcmlwdCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGxvYWQgR29vZ2xlIENoYXJ0cyBKUyBBUEkuXG4gKiBAcGFyYW0gcGFyYW1zIC0gTG9hZCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIFtwYXJhbXMuY2hhcnRWZXJzaW9uXSAtIENoYXJ0IHZlcnNpb24gdG8gbG9hZC5cbiAqIEBwYXJhbSBbcGFyYW1zLmNoYXJ0UGFja2FnZXNdIC0gUGFja2FnZXMgdG8gbG9hZC5cbiAqIEBwYXJhbSBbcGFyYW1zLmNoYXJ0TGFuZ3VhZ2VdIC0gTGFuZ3VhZ2VzIHRvIGxvYWQuXG4gKiBAcGFyYW0gW3BhcmFtcy5tYXBzQXBpS2V5XSAtIEdvb2dsZSBNYXBzIGFwaSBrZXkuXG4gKiBAcmV0dXJuc1xuICovIGZ1bmN0aW9uIHVzZUxvYWRHb29nbGVDaGFydHMocGFyYW0pIHtcbiAgICBsZXQgeyBjaGFydFZlcnNpb24gPVwiY3VycmVudFwiICwgY2hhcnRQYWNrYWdlcyA9W1xuICAgICAgICBcImNvcmVjaGFydFwiLFxuICAgICAgICBcImNvbnRyb2xzXCJcbiAgICBdICwgY2hhcnRMYW5ndWFnZSA9XCJlblwiICwgbWFwc0FwaUtleSAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IFtnb29nbGVDaGFydHMsIHNldEdvb2dsZUNoYXJ0c10gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbZmFpbGVkLCBzZXRGYWlsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUxvYWRTY3JpcHQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9jaGFydHMvbG9hZGVyLmpzXCIsICgpPT57XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgR2V0dGluZyBvYmplY3QgZnJvbSBnbG9iYWwgbmFtZXNwYWNlLlxuICAgICAgICBjb25zdCBnb29nbGUgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuZ29vZ2xlO1xuICAgICAgICBpZiAoIWdvb2dsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdvb2dsZS5jaGFydHMubG9hZChjaGFydFZlcnNpb24sIHtcbiAgICAgICAgICAgIHBhY2thZ2VzOiBjaGFydFBhY2thZ2VzLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGNoYXJ0TGFuZ3VhZ2UsXG4gICAgICAgICAgICBtYXBzQXBpS2V5XG4gICAgICAgIH0pO1xuICAgICAgICBnb29nbGUuY2hhcnRzLnNldE9uTG9hZENhbGxiYWNrKCgpPT57XG4gICAgICAgICAgICBzZXRHb29nbGVDaGFydHMoZ29vZ2xlKTtcbiAgICAgICAgfSk7XG4gICAgfSwgKCk9PntcbiAgICAgICAgc2V0RmFpbGVkKHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGdvb2dsZUNoYXJ0cyxcbiAgICAgICAgZmFpbGVkXG4gICAgXTtcbn1cbi8qKlxuICogV3JhcHBlciBhcm91bmQgdXNlTG9hZEdvb2dsZUNoYXJ0cyB0byB1c2UgaW4gbGVnYWN5IGNvbXBvbmVudHMuXG4gKi8gZnVuY3Rpb24gTG9hZEdvb2dsZUNoYXJ0cyhwYXJhbSkge1xuICAgIGxldCB7IG9uTG9hZCAsIG9uRXJyb3IgLCAuLi5wYXJhbXMgfSA9IHBhcmFtO1xuICAgIGNvbnN0IFtnb29nbGVDaGFydHMsIGZhaWxlZF0gPSB1c2VMb2FkR29vZ2xlQ2hhcnRzKHBhcmFtcyk7XG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChnb29nbGVDaGFydHMgJiYgb25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoZ29vZ2xlQ2hhcnRzKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZ29vZ2xlQ2hhcnRzXG4gICAgXSk7XG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChmYWlsZWQgJiYgb25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBmYWlsZWRcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgY2hhcnREZWZhdWx0UHJvcHMgPSB7XG4gICAgLy8gPERFUFJFQ0FURURfUFJPUFM+XG4gICAgbGVnZW5kX3RvZ2dsZTogZmFsc2UsXG4gICAgLy8gPC9ERVBSRUNBVEVEX1BST1BTPlxuICAgIG9wdGlvbnM6IHt9LFxuICAgIGxlZ2VuZFRvZ2dsZTogZmFsc2UsXG4gICAgZ2V0Q2hhcnRXcmFwcGVyOiAoKT0+e30sXG4gICAgc3ByZWFkU2hlZXRRdWVyeVBhcmFtZXRlcnM6IHtcbiAgICAgICAgaGVhZGVyczogMSxcbiAgICAgICAgZ2lkOiAxXG4gICAgfSxcbiAgICByb290UHJvcHM6IHt9LFxuICAgIGNoYXJ0V3JhcHBlclBhcmFtczoge31cbn07XG5cbmxldCB1bmlxdWVJRCA9IDA7XG5jb25zdCBnZW5lcmF0ZVVuaXF1ZUlEID0gKCk9PntcbiAgICB1bmlxdWVJRCArPSAxO1xuICAgIHJldHVybiBcInJlYWN0Z29vZ2xlZ3JhcGgtXCIuY29uY2F0KHVuaXF1ZUlEKTtcbn07XG5cbmNvbnN0IERFRkFVTFRfQ0hBUlRfQ09MT1JTID0gW1xuICAgIFwiIzMzNjZDQ1wiLFxuICAgIFwiI0RDMzkxMlwiLFxuICAgIFwiI0ZGOTkwMFwiLFxuICAgIFwiIzEwOTYxOFwiLFxuICAgIFwiIzk5MDA5OVwiLFxuICAgIFwiIzNCM0VBQ1wiLFxuICAgIFwiIzAwOTlDNlwiLFxuICAgIFwiI0RENDQ3N1wiLFxuICAgIFwiIzY2QUEwMFwiLFxuICAgIFwiI0I4MkUyRVwiLFxuICAgIFwiIzMxNjM5NVwiLFxuICAgIFwiIzk5NDQ5OVwiLFxuICAgIFwiIzIyQUE5OVwiLFxuICAgIFwiI0FBQUExMVwiLFxuICAgIFwiIzY2MzNDQ1wiLFxuICAgIFwiI0U2NzMwMFwiLFxuICAgIFwiIzhCMDcwN1wiLFxuICAgIFwiIzMyOTI2MlwiLFxuICAgIFwiIzU1NzRBNlwiLFxuICAgIFwiIzNCM0VBQ1wiXG5dO1xuXG5jb25zdCBsb2FkRGF0YVRhYmxlRnJvbVNwcmVhZFNoZWV0ID0gYXN5bmMgZnVuY3Rpb24oZ29vZ2xlVml6LCBzcHJlYWRTaGVldFVybCkge1xuICAgIGxldCB1cmxQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gXCJcIi5jb25jYXQodXJsUGFyYW1zLmhlYWRlcnMgPyBcImhlYWRlcnM9XCIuY29uY2F0KHVybFBhcmFtcy5oZWFkZXJzKSA6IFwiaGVhZGVycz0wXCIpO1xuICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IFwiXCIuY29uY2F0KHVybFBhcmFtcy5xdWVyeSA/IFwiJnRxPVwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLnF1ZXJ5KSkgOiBcIlwiKTtcbiAgICAgICAgY29uc3QgZ2lkID0gXCJcIi5jb25jYXQodXJsUGFyYW1zLmdpZCA/IFwiJmdpZD1cIi5jb25jYXQodXJsUGFyYW1zLmdpZCkgOiBcIlwiKTtcbiAgICAgICAgY29uc3Qgc2hlZXQgPSBcIlwiLmNvbmNhdCh1cmxQYXJhbXMuc2hlZXQgPyBcIiZzaGVldD1cIi5jb25jYXQodXJsUGFyYW1zLnNoZWV0KSA6IFwiXCIpO1xuICAgICAgICBjb25zdCBhY2Nlc3NfdG9rZW4gPSBcIlwiLmNvbmNhdCh1cmxQYXJhbXMuYWNjZXNzX3Rva2VuID8gXCImYWNjZXNzX3Rva2VuPVwiLmNvbmNhdCh1cmxQYXJhbXMuYWNjZXNzX3Rva2VuKSA6IFwiXCIpO1xuICAgICAgICBjb25zdCB1cmxRdWVyeVN0cmluZyA9IFwiXCIuY29uY2F0KGhlYWRlcnMpLmNvbmNhdChnaWQpLmNvbmNhdChzaGVldCkuY29uY2F0KHF1ZXJ5U3RyaW5nKS5jb25jYXQoYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgY29uc3QgdXJsVG9TcHJlYWRTaGVldCA9IFwiXCIuY29uY2F0KHNwcmVhZFNoZWV0VXJsLCBcIi9ndml6L3RxP1wiKS5jb25jYXQodXJsUXVlcnlTdHJpbmcpOyAvLyZ0cT0ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IGdvb2dsZVZpei52aXN1YWxpemF0aW9uLlF1ZXJ5KHVybFRvU3ByZWFkU2hlZXQpO1xuICAgICAgICBxdWVyeS5zZW5kKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvciBpbiBxdWVyeTogIFwiLmNvbmNhdChyZXNwb25zZS5nZXRNZXNzYWdlKCksIFwiIFwiKS5jb25jYXQocmVzcG9uc2UuZ2V0RGV0YWlsZWRNZXNzYWdlKCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5nZXREYXRhVGFibGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuY29uc3QgeyBQcm92aWRlciAsIENvbnN1bWVyICB9ID0gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVDb250ZXh0KGNoYXJ0RGVmYXVsdFByb3BzKTtcbmNvbnN0IENvbnRleHRQcm92aWRlciA9IChwYXJhbSk9PntcbiAgICBsZXQgeyBjaGlsZHJlbiAsIHZhbHVlICB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgQ29udGV4dENvbnN1bWVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IHJlbmRlciAgfSA9IHBhcmFtO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KT0+e1xuICAgICAgICByZXR1cm4gcmVuZGVyKGNvbnRleHQpO1xuICAgIH0pO1xufTtcblxuY29uc3QgR1JBWV9DT0xPUiA9IFwiI0NDQ0NDQ1wiO1xuY2xhc3MgR29vZ2xlQ2hhcnREYXRhVGFibGVJbm5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuZHJhdyh0aGlzLnByb3BzKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmxlZ2VuZF90b2dnbGUgfHwgdGhpcy5wcm9wcy5sZWdlbmRUb2dnbGUpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG9MZWdlbmRUb2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBnb29nbGUgLCBnb29nbGVDaGFydFdyYXBwZXIgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyhnb29nbGVDaGFydFdyYXBwZXIpO1xuICAgICAgICBpZiAoZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0VHlwZSgpID09PSBcIlRpbWVsaW5lXCIpIHtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydCgpICYmIGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydCgpLmNsZWFyQ2hhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZHJhdyh0aGlzLnByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaGlkZGVuQ29sdW1uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ub0xlZ2VuZFRvZ2dsZSA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCB7IGdvb2dsZSAsIGdvb2dsZUNoYXJ0V3JhcHBlciAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMuYWRkTGlzdGVuZXIoZ29vZ2xlQ2hhcnRXcmFwcGVyLCBcInNlbGVjdFwiLCAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gY2hhcnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVRhYmxlID0gZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldERhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09PSAwIHx8IC8vIFdlIHdhbnQgdG8gbGlzdGVuIHRvIHdoZW4gYSB3aG9sZSByb3cgaXMgc2VsZWN0ZWQuIFRoaXMgaXMgdGhlIGNhc2Ugb25seSB3aGVuIHJvdyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblswXS5yb3cgfHwgIWRhdGFUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gc2VsZWN0aW9uWzBdLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5JRCA9IHRoaXMuZ2V0Q29sdW1uSUQoZGF0YVRhYmxlLCBjb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGlkZGVuQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW5JRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbkNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaGlkZGVuQ29sdW1ucy5maWx0ZXIoKGNvbElEKT0+Y29sSUQgIT09IGNvbHVtbklEKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5Db2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmhpZGRlbkNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbklEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFwcGx5Rm9ybWF0dGVycyA9IChkYXRhVGFibGUsIGZvcm1hdHRlcnMpPT57XG4gICAgICAgICAgICBjb25zdCB7IGdvb2dsZSAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBmb3IgKGxldCBmb3JtYXR0ZXIgb2YgZm9ybWF0dGVycyl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGZvcm1hdHRlci50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93Rm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkFycm93Rm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCYXJGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXpGb3JtYXR0ZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQmFyRm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDb2xvckZvcm1hdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpekZvcm1hdHRlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5Db2xvckZvcm1hdChmb3JtYXR0ZXIub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgIH0gPSBmb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgcmFuZ2VzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmFkZFJhbmdlKC4uLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmZvcm1hdChkYXRhVGFibGUsIGZvcm1hdHRlci5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRGF0ZUZvcm1hdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpekZvcm1hdHRlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRlRm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOdW1iZXJGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXpGb3JtYXR0ZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uTnVtYmVyRm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJQYXR0ZXJuRm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLlBhdHRlcm5Gb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29sdW1uSUQgPSAoZGF0YVRhYmxlLCBjb2x1bW5JbmRleCk9PntcbiAgICAgICAgICAgIHJldHVybiBkYXRhVGFibGUuZ2V0Q29sdW1uSWQoY29sdW1uSW5kZXgpIHx8IGRhdGFUYWJsZS5nZXRDb2x1bW5MYWJlbChjb2x1bW5JbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZHJhdyA9IGFzeW5jIChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IGRhdGEgLCBkaWZmZGF0YSAsIHJvd3MgLCBjb2x1bW5zICwgb3B0aW9ucyAsIGxlZ2VuZF90b2dnbGUgLCBsZWdlbmRUb2dnbGUgLCBjaGFydFR5cGUgLCBmb3JtYXR0ZXJzICwgc3ByZWFkU2hlZXRVcmwgLCBzcHJlYWRTaGVldFF1ZXJ5UGFyYW1ldGVycyAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgY29uc3QgeyBnb29nbGUgLCBnb29nbGVDaGFydFdyYXBwZXIgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IGRhdGFUYWJsZTtcbiAgICAgICAgICAgIGxldCBjaGFydERpZmYgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGRpZmZkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoZGlmZmRhdGEub2xkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZShkaWZmZGF0YS5uZXcpO1xuICAgICAgICAgICAgICAgIGNoYXJ0RGlmZiA9IGdvb2dsZS52aXN1YWxpemF0aW9uW2NoYXJ0VHlwZV0ucHJvdG90eXBlLmNvbXB1dGVEaWZmKG9sZERhdGEsIG5ld0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGUgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZSA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dzICYmIGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkYXRhVGFibGUgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKFtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucm93c1xuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcHJlYWRTaGVldFVybCkge1xuICAgICAgICAgICAgICAgIGRhdGFUYWJsZSA9IGF3YWl0IGxvYWREYXRhVGFibGVGcm9tU3ByZWFkU2hlZXQoZ29vZ2xlLCBzcHJlYWRTaGVldFVybCwgc3ByZWFkU2hlZXRRdWVyeVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVGFibGUgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gZGF0YVRhYmxlLmdldE51bWJlck9mQ29sdW1ucygpO1xuICAgICAgICAgICAgY29uc3Qgdmlld0NvbHVtbnMgPSBBcnJheShjb2x1bW5Db3VudCkuZmlsbCgwKS5tYXAoKGMsIGkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uSUQgPSB0aGlzLmdldENvbHVtbklEKGRhdGFUYWJsZSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGlkZGVuQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW5JRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRhVGFibGUuZ2V0Q29sdW1uTGFiZWwoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBkYXRhVGFibGUuZ2V0Q29sdW1uVHlwZShpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGM6ICgpPT5udWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGFydCA9IGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydCgpO1xuICAgICAgICAgICAgaWYgKGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydFR5cGUoKSA9PT0gXCJUaW1lbGluZVwiKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQgJiYgY2hhcnQuY2xlYXJDaGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldENoYXJ0VHlwZShjaGFydFR5cGUpO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCB2aWV3VGFibGUgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVZpZXcoZGF0YVRhYmxlKTtcbiAgICAgICAgICAgIHZpZXdUYWJsZS5zZXRDb2x1bW5zKHZpZXdDb2x1bW5zKTtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXREYXRhVGFibGUodmlld1RhYmxlKTtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5nb29nbGVDaGFydERhc2hib2FyZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZ29vZ2xlQ2hhcnREYXNoYm9hcmQuZHJhdyhkYXRhVGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXJ0RGlmZikge1xuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXREYXRhVGFibGUoY2hhcnREaWZmKTtcbiAgICAgICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Rm9ybWF0dGVycyhkYXRhVGFibGUsIGZvcm1hdHRlcnMpO1xuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXREYXRhVGFibGUoZGF0YVRhYmxlKTtcbiAgICAgICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2VuZFRvZ2dsZSA9PT0gdHJ1ZSB8fCBsZWdlbmRfdG9nZ2xlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmF5T3V0SGlkZGVuQ29sdW1ucyh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmF5T3V0SGlkZGVuQ29sdW1ucyA9IChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ29vZ2xlQ2hhcnRXcmFwcGVyICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUYWJsZSA9IGdvb2dsZUNoYXJ0V3JhcHBlci5nZXREYXRhVGFibGUoKTtcbiAgICAgICAgICAgIGlmICghZGF0YVRhYmxlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5Db3VudCA9IGRhdGFUYWJsZS5nZXROdW1iZXJPZkNvbHVtbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0FIaWRkZW5Db2x1bW4gPSB0aGlzLnN0YXRlLmhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGlmIChoYXNBSGlkZGVuQ29sdW1uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBjb2x1bW5Db3VudCAtIDFcbiAgICAgICAgICAgIH0pLm1hcCgoZG9udGNhcmUsIGkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uSUQgPSB0aGlzLmdldENvbHVtbklEKGRhdGFUYWJsZSwgaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoY29sdW1uSUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHUkFZX0NPTE9SO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbG9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfQ0hBUlRfQ09MT1JTW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29sb3JzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZXNpemUgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBnb29nbGVDaGFydFdyYXBwZXIgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmRyYXcoKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBHb29nbGVDaGFydERhdGFUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7fVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge31cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGdvb2dsZSAsIGdvb2dsZUNoYXJ0V3JhcHBlciAsIGdvb2dsZUNoYXJ0RGFzaGJvYXJkICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0Q29uc3VtZXIsIHtcbiAgICAgICAgICAgIHJlbmRlcjogKHByb3BzKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlQ2hhcnREYXRhVGFibGVJbm5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlOiBnb29nbGUsXG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcjogZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgICAgICAgICBnb29nbGVDaGFydERhc2hib2FyZDogZ29vZ2xlQ2hhcnREYXNoYm9hcmRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgR29vZ2xlQ2hhcnRFdmVudHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsaXN0ZW5Ub0V2ZW50cyhwYXJhbSkge1xuICAgICAgICBsZXQgeyBjaGFydEV2ZW50cyAsIGdvb2dsZSAsIGdvb2dsZUNoYXJ0V3JhcHBlciAgfSA9IHBhcmFtO1xuICAgICAgICBpZiAoIWNoYXJ0RXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyhnb29nbGVDaGFydFdyYXBwZXIpO1xuICAgICAgICBmb3IgKGxldCBldmVudCBvZiBjaGFydEV2ZW50cyl7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBldmVudE5hbWUgLCBjYWxsYmFjayAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKGdvb2dsZUNoYXJ0V3JhcHBlciwgZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRXcmFwcGVyOiBnb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlOiBnb29nbGUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IHsgZ29vZ2xlICwgZ29vZ2xlQ2hhcnRXcmFwcGVyICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5saXN0ZW5Ub0V2ZW50cyh7XG4gICAgICAgICAgICBjaGFydEV2ZW50czogKChyZWYgPSB0aGlzLnByb3BzRnJvbUNvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNoYXJ0RXZlbnRzKSB8fCBudWxsLFxuICAgICAgICAgICAgZ29vZ2xlLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dENvbnN1bWVyLCB7XG4gICAgICAgICAgICByZW5kZXI6IChwcm9wc0Zyb21Db250ZXh0KT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNGcm9tQ29udGV4dCA9IHByb3BzRnJvbUNvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5wcm9wc0Zyb21Db250ZXh0ID0gbnVsbDtcbiAgICB9XG59XG5cbmxldCBjb250cm9sQ291bnRlciA9IDA7XG5jbGFzcyBHb29nbGVDaGFydCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyAsIGdvb2dsZSAsIGNoYXJ0VHlwZSAsIGNoYXJ0V3JhcHBlclBhcmFtcyAsIHRvb2xiYXJJdGVtcyAsIGdldENoYXJ0RWRpdG9yICwgZ2V0Q2hhcnRXcmFwcGVyICwgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjaGFydENvbmZpZyA9IHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250YWluZXJJZDogdGhpcy5nZXRHcmFwaElEKCksXG4gICAgICAgICAgICAuLi5jaGFydFdyYXBwZXJQYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ29vZ2xlQ2hhcnRXcmFwcGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkNoYXJ0V3JhcHBlcihjaGFydENvbmZpZyk7XG4gICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXRPcHRpb25zKG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoZ2V0Q2hhcnRXcmFwcGVyKSB7XG4gICAgICAgICAgICBnZXRDaGFydFdyYXBwZXIoZ29vZ2xlQ2hhcnRXcmFwcGVyLCBnb29nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdvb2dsZUNoYXJ0RGFzaGJvYXJkID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZCh0aGlzLmRhc2hib2FyZF9yZWYpO1xuICAgICAgICBjb25zdCBnb29nbGVDaGFydENvbnRyb2xzID0gdGhpcy5hZGRDb250cm9scyhnb29nbGVDaGFydFdyYXBwZXIsIGdvb2dsZUNoYXJ0RGFzaGJvYXJkKTtcbiAgICAgICAgaWYgKHRvb2xiYXJJdGVtcykge1xuICAgICAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZHJhd1Rvb2xiYXIodGhpcy50b29sYmFyX3JlZi5jdXJyZW50LCB0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb29nbGVDaGFydEVkaXRvciA9IG51bGw7XG4gICAgICAgIGlmIChnZXRDaGFydEVkaXRvcikge1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRFZGl0b3IgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRFZGl0b3IoKTtcbiAgICAgICAgICAgIGdldENoYXJ0RWRpdG9yKHtcbiAgICAgICAgICAgICAgICBjaGFydEVkaXRvcjogZ29vZ2xlQ2hhcnRFZGl0b3IsXG4gICAgICAgICAgICAgICAgY2hhcnRXcmFwcGVyOiBnb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZ29vZ2xlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RWRpdG9yLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRDb250cm9sczogZ29vZ2xlQ2hhcnRDb250cm9scyxcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkOiBnb29nbGVDaGFydERhc2hib2FyZCxcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgIGlzUmVhZHk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0V3JhcHBlcikgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnREYXNoYm9hcmQpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0Q29udHJvbHMpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBjb250cm9scyAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChjb250cm9scykge1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbnRyb2xzLmxlbmd0aDsgaSArPSAxKXtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xUeXBlICwgb3B0aW9ucyAsIGNvbnRyb2xXcmFwcGVyUGFyYW1zICB9ID0gY29udHJvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xXcmFwcGVyUGFyYW1zICYmIFwic3RhdGVcIiBpbiBjb250cm9sV3JhcHBlclBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0Q29udHJvbHNbaV0uY29udHJvbC5zZXRTdGF0ZShjb250cm9sV3JhcHBlclBhcmFtc1tcInN0YXRlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5nb29nbGVDaGFydENvbnRyb2xzW2ldLmNvbnRyb2wuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0Q29udHJvbHNbaV0uY29udHJvbC5zZXRDb250cm9sVHlwZShjb250cm9sVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUmVhZHkgIT09IG5leHRTdGF0ZS5pc1JlYWR5IHx8IG5leHRQcm9wcy5jb250cm9scyAhPT0gdGhpcy5wcm9wcy5jb250cm9scztcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoICwgaGVpZ2h0ICwgb3B0aW9ucyAsIHN0eWxlICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZGl2U3R5bGUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCBvcHRpb25zICYmIG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgIC4uLnN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLmRhc2hib2FyZF9yZWYsXG4gICAgICAgICAgICAgICAgc3R5bGU6IGRpdlN0eWxlXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogdGhpcy50b29sYmFyX3JlZixcbiAgICAgICAgICAgICAgICBpZDogXCJ0b29sYmFyXCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLnJlbmRlcih7XG4gICAgICAgICAgICAgICAgcmVuZGVyQ2hhcnQ6IHRoaXMucmVuZGVyQ2hhcnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyQ29udHJvbDogdGhpcy5yZW5kZXJDb250cm9sLFxuICAgICAgICAgICAgICAgIHJlbmRlclRvb2xiYXI6IHRoaXMucmVuZGVyVG9vbEJhclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLmRhc2hib2FyZF9yZWYsXG4gICAgICAgICAgICAgICAgc3R5bGU6IGRpdlN0eWxlXG4gICAgICAgICAgICB9LCB0aGlzLnJlbmRlckNvbnRyb2woKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRyb2xQcm9wICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xQcm9wLmNvbnRyb2xQb3NpdGlvbiAhPT0gXCJib3R0b21cIjtcbiAgICAgICAgICAgIH0pLCB0aGlzLnJlbmRlckNoYXJ0KCksIHRoaXMucmVuZGVyQ29udHJvbCgocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IHsgY29udHJvbFByb3AgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbFByb3AuY29udHJvbFBvc2l0aW9uID09PSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgfSksIHRoaXMucmVuZGVyVG9vbEJhcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzMSl7XG4gICAgICAgIHZhciBfdGhpczE7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MxKSwgX3RoaXMxID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcjogbnVsbCxcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkOiBudWxsLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRDb250cm9sczogbnVsbCxcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RWRpdG9yOiBudWxsLFxuICAgICAgICAgICAgaXNSZWFkeTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmFwaElEID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRfcmVmID0gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy50b29sYmFyX3JlZiA9IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuZ2V0R3JhcGhJRCA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCB7IGdyYXBoSUQgLCBncmFwaF9pZCAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VHcmFwaElEO1xuICAgICAgICAgICAgaWYgKCFncmFwaElEICYmICFncmFwaF9pZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ncmFwaElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlR3JhcGhJRCA9IGdlbmVyYXRlVW5pcXVlSUQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUdyYXBoSUQgPSB0aGlzLmdyYXBoSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChncmFwaElEICYmICFncmFwaF9pZCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlR3JhcGhJRCA9IGdyYXBoSUQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyYXBoX2lkICYmICFncmFwaElEKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VHcmFwaElEID0gZ3JhcGhfaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlR3JhcGhJRCA9IGdyYXBoSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyYXBoSUQgPSBpbnN0YW5jZUdyYXBoSUQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaElEO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbnRyb2xJRCA9IChpZCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb250cm9sQ291bnRlciArPSAxO1xuICAgICAgICAgICAgbGV0IGNvbnRyb2xJRDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sSUQgPSBcImdvb2dsZWNoYXJ0LWNvbnRyb2wtXCIuY29uY2F0KGluZGV4LCBcIi1cIikuY29uY2F0KGNvbnRyb2xDb3VudGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbElEID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbElEO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZENvbnRyb2xzID0gKGdvb2dsZUNoYXJ0V3JhcHBlciwgZ29vZ2xlQ2hhcnREYXNoYm9hcmQpPT57XG4gICAgICAgICAgICBjb25zdCB7IGdvb2dsZSAsIGNvbnRyb2xzICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGdvb2dsZUNoYXJ0Q29udHJvbHMgPSAhY29udHJvbHMgPyBudWxsIDogY29udHJvbHMubWFwKChjb250cm9sLCBpKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbElEOiBjb250cm9sSURNYXliZSAsIGNvbnRyb2xUeXBlICwgb3B0aW9uczogY29udHJvbE9wdGlvbnMgLCBjb250cm9sV3JhcHBlclBhcmFtcyAsICB9ID0gY29udHJvbDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sSUQgPSB0aGlzLmdldENvbnRyb2xJRChjb250cm9sSURNYXliZSwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFByb3A6IGNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5Db250cm9sV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJZDogY29udHJvbElELFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBjb250cm9sT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2xXcmFwcGVyUGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFnb29nbGVDaGFydENvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnb29nbGVDaGFydERhc2hib2FyZC5iaW5kKGdvb2dsZUNoYXJ0Q29udHJvbHMubWFwKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250cm9sICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgICAgICAgICB9KSwgZ29vZ2xlQ2hhcnRXcmFwcGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoYXJ0Q29udHJvbCBvZiBnb29nbGVDaGFydENvbnRyb2xzKXtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnRyb2wgLCBjb250cm9sUHJvcCAgfSA9IGNoYXJ0Q29udHJvbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xFdmVudHMgPVtdICB9ID0gY29udHJvbFByb3A7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgY29udHJvbEV2ZW50cyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FsbGJhY2sgLCBldmVudE5hbWUgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGNvbnRyb2wsIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMuYWRkTGlzdGVuZXIoY29udHJvbCwgZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0V3JhcHBlcjogZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xXcmFwcGVyOiBjb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb29nbGU6IGdvb2dsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ29vZ2xlQ2hhcnRDb250cm9scztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJDaGFydCA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoICwgaGVpZ2h0ICwgb3B0aW9ucyAsIHN0eWxlICwgY2xhc3NOYW1lICwgcm9vdFByb3BzICwgZ29vZ2xlICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGRpdlN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAuLi5zdHlsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0R3JhcGhJRCgpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBkaXZTdHlsZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgICAgICAgfSwgcm9vdFByb3BzKSwgdGhpcy5zdGF0ZS5pc1JlYWR5ICYmIHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRXcmFwcGVyICE9PSBudWxsID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlQ2hhcnREYXRhVGFibGUsIHtcbiAgICAgICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXI6IHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgICAgIGdvb2dsZTogZ29vZ2xlLFxuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkOiB0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0RGFzaGJvYXJkXG4gICAgICAgICAgICB9KSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KEdvb2dsZUNoYXJ0RXZlbnRzLCB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyOiB0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgICAgICBnb29nbGU6IGdvb2dsZVxuICAgICAgICAgICAgfSkpIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyQ29udHJvbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGZpbHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczEuc3RhdGUuaXNSZWFkeSAmJiBfdGhpczEuc3RhdGUuZ29vZ2xlQ2hhcnRDb250cm9scyAhPT0gbnVsbCA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgX3RoaXMxLnN0YXRlLmdvb2dsZUNoYXJ0Q29udHJvbHMuZmlsdGVyKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250cm9sUHJvcCAsIGNvbnRyb2wgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFByb3BcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLm1hcCgocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IHsgY29udHJvbCAsIGNvbnRyb2xQcm9wICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbC5nZXRDb250YWluZXJJZCgpLFxuICAgICAgICAgICAgICAgICAgICBpZDogY29udHJvbC5nZXRDb250YWluZXJJZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlclRvb2xCYXIgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLnRvb2xiYXJJdGVtcykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMudG9vbGJhcl9yZWZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgQ2hhcnQkMSBleHRlbmRzIChSZWFjdC5Db21wb25lbnQpIHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhcnRMYW5ndWFnZSAsIGNoYXJ0UGFja2FnZXMgLCBjaGFydFZlcnNpb24gLCBtYXBzQXBpS2V5ICwgbG9hZGVyICwgZXJyb3JFbGVtZW50ICwgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMucHJvcHNcbiAgICAgICAgfSwgdGhpcy5zdGF0ZS5sb2FkaW5nU3RhdHVzID09PSBcInJlYWR5XCIgJiYgdGhpcy5zdGF0ZS5nb29nbGUgIT09IG51bGwgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlQ2hhcnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgICAgIGdvb2dsZTogdGhpcy5zdGF0ZS5nb29nbGVcbiAgICAgICAgfSkpIDogdGhpcy5zdGF0ZS5sb2FkaW5nU3RhdHVzID09PSBcImVycm9yZWRcIiAmJiBlcnJvckVsZW1lbnQgPyBlcnJvckVsZW1lbnQgOiBsb2FkZXIsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkR29vZ2xlQ2hhcnRzLCB7XG4gICAgICAgICAgICBjaGFydExhbmd1YWdlOiBjaGFydExhbmd1YWdlLFxuICAgICAgICAgICAgY2hhcnRQYWNrYWdlczogY2hhcnRQYWNrYWdlcyxcbiAgICAgICAgICAgIGNoYXJ0VmVyc2lvbjogY2hhcnRWZXJzaW9uLFxuICAgICAgICAgICAgbWFwc0FwaUtleTogbWFwc0FwaUtleSxcbiAgICAgICAgICAgIG9uTG9hZDogdGhpcy5vbkxvYWQsXG4gICAgICAgICAgICBvbkVycm9yOiB0aGlzLm9uRXJyb3JcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpc0Z1bGx5TG9hZGVkKGdvb2dsZSkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xzICwgdG9vbGJhckl0ZW1zICwgZ2V0Q2hhcnRFZGl0b3IgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gZ29vZ2xlICYmIGdvb2dsZS52aXN1YWxpemF0aW9uICYmIGdvb2dsZS52aXN1YWxpemF0aW9uLkNoYXJ0V3JhcHBlciAmJiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQgJiYgKCFjb250cm9scyB8fCBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFdyYXBwZXIpICYmICghZ2V0Q2hhcnRFZGl0b3IgfHwgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRFZGl0b3IpICYmICghdG9vbGJhckl0ZW1zIHx8IGdvb2dsZS52aXN1YWxpemF0aW9uLmRyYXdUb29sYmFyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGxvYWRpbmdTdGF0dXM6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgZ29vZ2xlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Mb2FkID0gKGdvb2dsZTEpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZChnb29nbGUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRnVsbHlMb2FkZWQoZ29vZ2xlMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzcyhnb29nbGUxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMTogd2luZG93Lmdvb2dsZSBpcyBub3QgZnVsbHkgc2V0LCB3ZSBoYXZlIHRvIHdhaXRcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdvb2dsZSA9IHdpbmRvdy5nb29nbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnb29nbGUgJiYgdGhpcy5pc0Z1bGx5TG9hZGVkKGdvb2dsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzcyhnb29nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSAoZ29vZ2xlKT0+e1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1N0YXR1czogXCJyZWFkeVwiLFxuICAgICAgICAgICAgICAgIGdvb2dsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25FcnJvciA9ICgpPT57XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RhdHVzOiBcImVycm9yZWRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuQ2hhcnQkMS5kZWZhdWx0UHJvcHMgPSBjaGFydERlZmF1bHRQcm9wcztcblxudmFyIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlO1xuKGZ1bmN0aW9uKEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlKSB7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJhbm5vdGF0aW9uXCJdID0gXCJhbm5vdGF0aW9uXCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJhbm5vdGF0aW9uVGV4dFwiXSA9IFwiYW5ub3RhdGlvblRleHRcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImNlcnRhaW50eVwiXSA9IFwiY2VydGFpbnR5XCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJlbXBoYXNpc1wiXSA9IFwiZW1waGFzaXNcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImludGVydmFsXCJdID0gXCJpbnRlcnZhbFwiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1wic2NvcGVcIl0gPSBcInNjb3BlXCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJzdHlsZVwiXSA9IFwic3R5bGVcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcInRvb2x0aXBcIl0gPSBcInRvb2x0aXBcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImRvbWFpblwiXSA9IFwiZG9tYWluXCI7XG59KShHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZSB8fCAoR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGUgPSB7fSkpO1xuXG52YXIgQ2hhcnQgPSBDaGFydCQxO1xuXG5leHBvcnQgeyBDaGFydCQxIGFzIENoYXJ0LCBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZSwgQ2hhcnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-google-charts/dist/index.js\n");

/***/ })

};
;